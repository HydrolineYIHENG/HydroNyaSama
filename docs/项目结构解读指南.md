# 项目结构解读指南（HydroNyaSama，通俗版）

本文面向“未来要持续往本仓库移植更多模块/新增更多内容”的开发场景，尽量用更通俗的方式说明：
- 这仓库在做什么
- 哪些目录该放什么
- 新功能通常要改哪些地方

## 1. 总览：这是一个“多版本 + 双 Loader + 共享 common”的工程

- **支持矩阵**：Minecraft `1.16.5 / 1.18.2 / 1.20.1` × `Forge / Fabric`。
- **一句话理解**：你写的“业务逻辑”放 common；“怎么跟 Forge/Fabric 打交道”放各自的 loader 子工程；根工程负责把它们组合成多个版本的 jar。
- **构建入口**：根 [`build.gradle.kts`](file:///c:/Users/Administrator/Pictures/HydroNyaSama/build.gradle.kts) 中的 `supportedTargets`、`loaderProjects`、`configureLoaderProject` 决定了所有子工程的依赖、打包与重定位策略。

## 2. 目录结构：每层的职责边界

### 2.1 `common/`（共享逻辑层）

把 common 当成“纯业务后端 + 协议库”，它不关心你是在 Forge 还是 Fabric，也不关心具体 MC 版本。

放什么（能跨版本复用的东西）：
- 协议定义：请求/响应结构、错误码、序列化
- 业务逻辑：处理 action、读写数据、限流/缓存、DTO 转换
- 跨平台抽象：把“平台差异”包进接口，由 loader 去实现

允许依赖：
- JDK
- （编译期）MTR API（`compileOnly`）
- 项目内部工具类

不放什么：
- 任何“只能在 Forge/Fabric 上用”的代码，比如：
  - Forge：`DeferredRegister`、事件总线订阅、Forge 专属生命周期
  - Fabric：`Registry.register`、Fabric 专属事件/回调
- 任何“直接依赖 net.minecraft 的方块/物品注册实现”，因为这些类在不同版本差异很大，放 common 会把 common 绑死到某个版本

关键入口与包：
- Mod 共享初始化入口：[BeaconProviderMod.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/common/src/main/java/cn/hydcraft/hydronyasama/BeaconProviderMod.java)
- 通信协议与常量：`cn.hydcraft.hydronyasama.protocol.*`（例：[ChannelConstants.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/common/src/main/java/cn/hydcraft/hydronyasama/protocol/ChannelConstants.java)）
- 请求路由与传输：`cn.hydcraft.hydronyasama.transport.*`（例：[ChannelMessageRouter.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/common/src/main/java/cn/hydcraft/hydronyasama/transport/ChannelMessageRouter.java)）
- 服务层与 action handler：`cn.hydcraft.hydronyasama.service.*`

### 2.2 `fabric-<mc>/` 与 `forge-<mc>/`（平台适配层）

把每个 `fabric-<mc>` / `forge-<mc>` 当成“接线员”：
- 它们负责把 Minecraft/Loader 的事件、注册系统、网络 API 接到 common 的业务上
- common 只告诉你“要做什么”，这里负责“怎么做”

放什么：
- Loader 入口类（Fabric `ModInitializer`、Forge `@Mod`）
- 生命周期事件绑定、网络收发的 glue code
- 注册 blocks/items/commands 等所有“需要平台 API”的东西

不放什么：
- 可复用的业务规则（应回流到 `common/`）。

入口位置：
- Fabric 入口：`cn.hydcraft.hydronyasama.fabric.BeaconProviderFabric`
  - 例：[fabric-1.20.1 BeaconProviderFabric.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/fabric-1.20.1/src/main/java/cn/hydcraft/hydronyasama/fabric/BeaconProviderFabric.java)
- Forge 入口：`cn.hydcraft.hydronyasama.forge.BeaconProviderForge`
  - 例：[forge-1.20.1 BeaconProviderForge.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/forge-1.20.1/src/main/java/cn/hydcraft/hydronyasama/forge/BeaconProviderForge.java)

## 3. 构建系统：如何添加/升级版本

### 3.1 添加新 Minecraft 版本（建议流程）

通俗讲：你要让“新版本也能编译出 jar”，根工程就要知道它的版本号、依赖 jar 放哪里、以及这个版本的 Forge/Fabric 子工程存在。

1. 在根 [`build.gradle.kts`](file:///c:/Users/Administrator/Pictures/HydroNyaSama/build.gradle.kts) 的 `supportedTargets` 增加一个 `McTarget`（minecraftVersion/forgeVersion/fabricLoaderVersion/fabricApiVersion/javaVersion/packFormat）。
2. 在 `loaderProjects` 增加对应的 `fabric-<mc>` 与 `forge-<mc>` 两个子工程（需要在仓库里创建对应目录与基础文件）。
3. 把目标版本的 MTR jar 放到 `libs/mtr3/`，并补齐 `mtrJarNameMap` 映射（否则编译会直接失败）。
4. 如该版本需要 Create：补 `createVersionMap`（或按现有 1.18.2 的方式放入 `libs/create` 并映射）。

### 3.2 为什么会看到 shadow/relocate

- 根构建会把 Architectury API 以 shadow 方式打进最终 jar，并 relocate 到 `cn.hydcraft.hydronyasama.shaded.architectury`，避免与其他 mod 的同名类冲突（实现细节见根脚本的 `shadowJar` 配置）。

## 4. 网络与协议：从 Bukkit 到 Mod 的链路

如果你要新增一个对外能力（比如新增 action），建议先理解这条链路：Bukkit 发请求 → Mod 收到 → common 解析并路由 → 执行业务 → 回包。

对应文档：
- 通道与 JSON 格式：[Channel API.md](file:///c:/Users/Administrator/Pictures/HydroNyaSama/docs/Channel%20API.md)
- Netty 网关与 Forge 管线拦截：[Netty Gateway.md](file:///c:/Users/Administrator/Pictures/HydroNyaSama/docs/Netty%20Gateway.md)
- Action 列表与语义：[Beacon Actions.md](file:///c:/Users/Administrator/Pictures/HydroNyaSama/docs/Beacon%20Actions.md)

实现位置（建议从这里读起）：
- 共享路由：[ChannelMessageRouter.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/common/src/main/java/cn/hydcraft/hydronyasama/transport/ChannelMessageRouter.java)
- Fabric 网络 glue：`fabric-*/.../network/*`
- Forge 网络 glue：`forge-*/.../network/*`

## 5. “移植更多内容”的落点指南（最常见问题）

### 5.1 我要新增一个业务模块（例如：新的数据源/新的 action）

推荐落点：
- common：新增 `service/<module>/...ActionHandler`、DTO/serializer、必要的 registry 注入点（参考 `MtrQueryRegistry`/`CreateQueryRegistry` 的 “AtomicReference 注入”模式）。
- loader：如需要依赖某个 Loader 才有的 API（事件、Hook），就写一个薄的 glue，在入口处初始化并把实现注册回 common。

### 5.2 我要新增方块/物品（跨版本/跨 Loader）

最容易踩坑的点在这里：不同 MC 版本的方块/物品类名、属性系统、注册 API 都不完全一样。
因此推荐做法不是“把注册实现写进 common”，而是：
- common 只描述“我要哪些内容”（id、种类、材质/纹理等 spec）
- loader 才做“怎么注册、怎么 new 出真正的 Block/Item”

当前已落地的模式是（你现在新增内容就按这个写）：
- common：只写“内容声明”（id、类型、材质/纹理等 spec），由 `ModContent.bootstrap(...)` 统一触发注册
  - 内容声明接口与聚合入口：`cn.hydcraft.hydronyasama.core.registry.*`、`cn.hydcraft.hydronyasama.core.content.*`
  - 示例： [BuildingContent.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/common/src/main/java/cn/hydcraft/hydronyasama/building/content/BuildingContent.java)
- loader：各版本/各 Loader 写真正的注册实现（Forge 用 DeferredRegister，Fabric 用 Registry.register）
  - 例： [forge-1.20.1 ForgeContentRegistrar.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/forge-1.20.1/src/main/java/cn/hydcraft/hydronyasama/forge/content/ForgeContentRegistrar.java)
  - 例： [fabric-1.20.1 FabricContentRegistrar.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/fabric-1.20.1/src/main/java/cn/hydcraft/hydronyasama/fabric/content/FabricContentRegistrar.java)

这样做的收益：
- common 不需要依赖任何一个具体版本的 `net.minecraft.*`，从而能稳定复用。
- 版本差异被压缩在极少数 `*ContentRegistrar`/工厂方法里，不会扩散到业务模块。

### 5.3 资源（assets）应该放哪里

- **可跨版本复用的资源**：优先放 `common/src/main/resources/assets/<modid>/...`，打包时会被合入每个最终 jar。
- **版本差异资源**：才放到对应 `fabric-<mc>/src/main/resources` 或 `forge-<mc>/src/main/resources`。

注意：
- 语言文件优先使用 `lang/zh_cn.json`、`lang/en_us.json`（现代版本格式）。
- pack.mcmeta 的 `pack_format` 是版本相关的，如需要可在各版本子工程单独提供。

## 6. 读代码的推荐路径（最省时间）

如果你第一次接手这个仓库，按下面顺序读，基本不会迷路：

1. 先看根构建脚本如何把 common 合入并生成矩阵 jar：[build.gradle.kts](file:///c:/Users/Administrator/Pictures/HydroNyaSama/build.gradle.kts)
2. 再看共享入口如何初始化： [BeaconProviderMod.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/common/src/main/java/cn/hydcraft/hydronyasama/BeaconProviderMod.java)
3. 看网络如何进入共享路由：Fabric/Forge 的 `*BeaconNetwork` + [ChannelMessageRouter.java](file:///c:/Users/Administrator/Pictures/HydroNyaSama/common/src/main/java/cn/hydcraft/hydronyasama/transport/ChannelMessageRouter.java)
4. 最后再下钻到具体模块：`mtr/*`、`create/*`、`service/*`

## 7. 快速对照表（写新东西时直接查）

| 你要做的事 | 主要改 common | 主要改 loader |
| --- | --- | --- |
| 新增 action（对外 API） | `service/*` + `protocol/*` | `*BeaconNetwork`（通常不需要改） |
| 新增平台能力（监听事件、hook） | 定义接口/抽象 + 把能力注入 common | 用 Forge/Fabric API 实现并在入口初始化 |
| 新增方块/物品 | 增加内容声明（spec） | 在各版本实现真正注册与 new Block/Item |
| 新增资源文件 | `common/resources`（能复用时） | 只有版本差异才放各版本 resources |


